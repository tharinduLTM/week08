  - name: Wait for Backend LoadBalancer IPs
    id: capture_ips
    env:
      NS: default                       # change if your services are in another namespace
      PRODSVC: product-service-w08e1
      ORDERSVC: order-service-w08e1
    run: |
      echo "Waiting for LoadBalancer IPs in namespace: $NS ..."
      PRODUCT_IP=""
      ORDER_IP=""

    # 120 * 5s = 10 minutes
      for i in $(seq 1 120); do
      echo "Attempt $i/120 ..."
      # Try IP first
      PIP=$(kubectl -n "$NS" get svc "$PRODSVC" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
      OIP=$(kubectl -n "$NS" get svc "$ORDERSVC" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
      # Fallback to hostname if IP not present yet
      if [ -z "$PIP" ]; then
        PIP=$(kubectl -n "$NS" get svc "$PRODSVC" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
      fi
      if [ -z "$OIP" ]; then
        OIP=$(kubectl -n "$NS" get svc "$ORDERSVC" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
      fi

      if [[ -n "$PIP" && -n "$OIP" ]]; then
        echo "Resolved addresses: product=$PIP order=$OIP"
        echo "PRODUCT_IP=$PIP" >> $GITHUB_ENV
        echo "ORDER_IP=$OIP"   >> $GITHUB_ENV
        kubectl -n "$NS" get svc "$PRODSVC" "$ORDERSVC" -o wide
        exit 0
      fi
      sleep 5
    done

    echo "Timed out waiting for LoadBalancer addresses."
    kubectl -n "$NS" get svc "$PRODSVC" "$ORDERSVC" -o wide || true
    kubectl -n "$NS" describe svc "$PRODSVC" || true
    kubectl -n "$NS" describe svc "$ORDERSVC" || true
    exit 1
